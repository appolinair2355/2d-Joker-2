#!/usr/bin/env python3
"""
Bot de Pr√©diction Telegram v2024 - Version Render.com
Architecture 100% YAML autonome - Aucune base de donn√©es PostgreSQL requise
Logique des As optimis√©e : 1 As premier groupe + 0 As deuxi√®me groupe
"""

import os
import asyncio
import re
import logging
import sys
import json
import yaml
import time
from datetime import datetime, timedelta
from telethon import TelegramClient, events
from aiohttp import web

# Configuration des logs optimis√©e pour Render.com
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)

# Variables d'environnement
API_ID = int(os.getenv('API_ID', '0'))
API_HASH = os.getenv('API_HASH', '')
BOT_TOKEN = os.getenv('BOT_TOKEN', '')
ADMIN_ID = int(os.getenv('ADMIN_ID', '0'))
PORT = int(os.getenv('PORT', '10000'))
prediction_interval = int(os.getenv('PREDICTION_INTERVAL', '1'))

# Variables d'√©tat globales - Configuration automatique
detected_stat_channel = -1002646551216  # Canal stats pr√©-configur√©
detected_display_channel = -1002716137113  # Canal display pr√©-configur√©
prediction_status = {}
last_predictions = []
status_log = []

# Client Telegram
session_name = f'bot_session_{int(time.time())}'
client = TelegramClient(session_name, API_ID, API_HASH)

# Gestionnaire YAML autonome
class SimpleYAMLManager:
    def __init__(self):
        self.data_dir = "data"
        if not os.path.exists(self.data_dir):
            os.makedirs(self.data_dir)
    
    def save_predictions(self, predictions):
        try:
            with open(f"{self.data_dir}/predictions.yaml", 'w') as f:
                yaml.dump(predictions, f, default_flow_style=False)
        except Exception as e:
            logger.error(f"Erreur sauvegarde pr√©dictions: {e}")
    
    def load_predictions(self):
        try:
            if os.path.exists(f"{self.data_dir}/predictions.yaml"):
                with open(f"{self.data_dir}/predictions.yaml", 'r') as f:
                    return yaml.safe_load(f) or {}
        except Exception as e:
            logger.error(f"Erreur chargement pr√©dictions: {e}")
        return {}

yaml_manager = SimpleYAMLManager()

# Pr√©dicteur de cartes autonome
class SimplePredictor:
    def __init__(self):
        self.prediction_status = yaml_manager.load_predictions()
        self.last_predictions = []
        self.status_log = []
        self.suits_mapping = {
            '‚ô†Ô∏è': '‚ô†', '‚ô•Ô∏è': '‚ô•', '‚ô¶Ô∏è': '‚ô¶', '‚ô£Ô∏è': '‚ô£',
            '‚ô†': '‚ô†', '‚ô•': '‚ô•', '‚ô¶': '‚ô¶', '‚ô£': '‚ô£'
        }
    
    def extract_game_number(self, text):
        """Extrait le num√©ro de jeu du message"""
        patterns = [
            r'#[Nn](\d+)',
            r'#(\d+)',
            r'(\d+)\.',
            r'Jeu\s*(\d+)',
            r'Game\s*(\d+)'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, text)
            if match:
                return int(match.group(1))
        return None
    
    def has_ace_in_group(self, group_text):
        """V√©rifie si un groupe contient des As"""
        return bool(re.search(r'A[‚ô†‚ô•‚ô¶‚ô£Ô∏è]', group_text))
    
    def count_aces_in_group(self, group_text):
        """Compte le nombre d'As dans un groupe"""
        return len(re.findall(r'A[‚ô†‚ô•‚ô¶‚ô£Ô∏è]', group_text))
    
    def extract_suits_from_group(self, group_text):
        """Extrait les couleurs d'un groupe de cartes"""
        suits = re.findall(r'[‚ô†‚ô•‚ô¶‚ô£]', group_text)
        return [self.suits_mapping.get(s, s) for s in suits]
    
    def should_predict(self, message_text):
        """D√©termine si une pr√©diction doit √™tre lanc√©e selon la logique des As"""
        try:
            # Extraire le num√©ro de jeu
            game_number = self.extract_game_number(message_text)
            if not game_number:
                return False, None, None
            
            # Rechercher les groupes de cartes avec pattern flexible
            patterns = [
                r'(\d+)\(([^)]+)\)\s*-\s*[‚úÖüî∞]*\s*(\d+)\(([^)]+)\)',
                r'(\d+)\(([^)]+)\)\s*[‚úÖüî∞-]*\s*(\d+)\(([^)]+)\)',
                r'\(([^)]+)\)\s*-\s*[‚úÖüî∞]*\s*\(([^)]+)\)'
            ]
            
            first_group = None
            second_group = None
            
            for pattern in patterns:
                match = re.search(pattern, message_text)
                if match:
                    groups = match.groups()
                    if len(groups) == 4:  # Avec num√©ros
                        first_group = groups[1]
                        second_group = groups[3]
                    elif len(groups) == 2:  # Sans num√©ros
                        first_group = groups[0]
                        second_group = groups[1]
                    break
            
            if not first_group or not second_group:
                logger.debug(f"Groupes non trouv√©s dans: {message_text}")
                return False, None, None
            
            # Compter les As dans chaque groupe
            aces_first = self.count_aces_in_group(first_group)
            aces_second = self.count_aces_in_group(second_group)
            
            logger.info(f"üéØ Analyse As: Premier groupe='{first_group}' (As: {aces_first > 0}), Deuxi√®me groupe='{second_group}' (As: {aces_second > 0})")
            
            # Logique des As: exactement 1 As dans le premier groupe ET 0 As dans le deuxi√®me
            if aces_first == 1 and aces_second == 0:
                logger.info("‚úÖ Condition As valid√©e: 1 As premier groupe + 0 As deuxi√®me groupe")
                
                # Extraire les couleurs du premier groupe pour la pr√©diction
                suits = self.extract_suits_from_group(first_group)
                suit_prediction = ''.join(suits[:2]) if len(suits) >= 2 else '‚ô£‚ô•'
                
                next_game = game_number + 1
                
                # V√©rifier si une pr√©diction existe d√©j√†
                if next_game in self.prediction_status:
                    logger.info(f"‚ùå Pr√©diction d√©j√† existante pour le jeu #{next_game} (statut: {self.prediction_status[next_game]}), ignor√©")
                    return False, None, None
                
                return True, next_game, suit_prediction
            else:
                if aces_first == 0:
                    logger.info("‚ùå Pas d'As dans le premier groupe, pas de pr√©diction")
                elif aces_first > 1:
                    logger.info(f"‚ùå Trop d'As dans le premier groupe ({aces_first}), pas de pr√©diction")
                elif aces_second > 0:
                    logger.info(f"‚ùå As d√©tect√© dans le deuxi√®me groupe ({aces_second}), pas de pr√©diction")
                
                return False, None, None
                
        except Exception as e:
            logger.error(f"Erreur should_predict: {e}")
            return False, None, None
    
    def verify_prediction(self, message_text):
        """V√©rifie les r√©sultats des pr√©dictions"""
        try:
            game_number = self.extract_game_number(message_text)
            if not game_number:
                return None, None
            
            # V√©rifier si c'est un r√©sultat final (avec ‚úÖ ou üî∞)
            if not re.search(r'[‚úÖüî∞]', message_text):
                return None, None
            
            # Extraire les groupes pour valider le format 2+2
            patterns = [
                r'(\d+)\(([^)]+)\)\s*-\s*[‚úÖüî∞]*\s*(\d+)\(([^)]+)\)',
                r'\(([^)]+)\)\s*-\s*[‚úÖüî∞]*\s*\(([^)]+)\)'
            ]
            
            first_group = None
            second_group = None
            
            for pattern in patterns:
                match = re.search(pattern, message_text)
                if match:
                    groups = match.groups()
                    if len(groups) == 4:
                        first_group = groups[1]
                        second_group = groups[3]
                    elif len(groups) == 2:
                        first_group = groups[0]
                        second_group = groups[1]
                    break
            
            if not first_group or not second_group:
                return None, None
            
            # Compter les cartes dans chaque groupe
            cards_first = len(re.findall(r'[‚ô†‚ô•‚ô¶‚ô£]', first_group))
            cards_second = len(re.findall(r'[‚ô†‚ô•‚ô¶‚ô£]', second_group))
            
            logger.info(f"Comptage cartes: groupe1={cards_first}, groupe2={cards_second}")
            
            # Valider le format 2+2
            if cards_first != 2 or cards_second != 2:
                logger.info("‚ùå R√©sultat invalide: pas exactement 2+2 cartes, ignor√© pour v√©rification")
                return None, None
            
            logger.info("‚úÖ R√©sultat valide (2+2)")
            
            # V√©rifier les pr√©dictions avec offsets 0, 1, 2, 3
            for offset in range(4):
                predicted_number = game_number - offset
                logger.info(f"V√©rification si le jeu #{game_number} correspond √† la pr√©diction #{predicted_number} (offset {offset})")
                
                if predicted_number in self.prediction_status:
                    current_status = self.prediction_status[predicted_number]
                    if current_status == '‚åõ':  # En attente
                        logger.info(f"Pr√©diction en attente trouv√©e: #{predicted_number}")
                        
                        # D√©terminer le statut selon l'offset
                        if offset == 0:
                            statut = '‚úÖ0Ô∏è‚É£'  # Exact
                        elif offset == 1:
                            statut = '‚úÖ1Ô∏è‚É£'  # 1 jeu apr√®s
                        elif offset == 2:
                            statut = '‚úÖ2Ô∏è‚É£'  # 2 jeux apr√®s
                        else:  # offset == 3
                            statut = '‚úÖ3Ô∏è‚É£'  # 3 jeux apr√®s
                        
                        self.prediction_status[predicted_number] = statut
                        self.status_log.append((predicted_number, statut))
                        yaml_manager.save_predictions(self.prediction_status)
                        
                        logger.info(f"‚úÖ Pr√©diction r√©ussie: #{predicted_number} valid√©e par le jeu #{game_number} (offset {offset})")
                        return True, predicted_number
            
            # Marquer les anciennes pr√©dictions comme √©chec si le jeu d√©passe pr√©diction+3
            for pred_num in list(self.prediction_status.keys()):
                if (self.prediction_status[pred_num] == '‚åõ' and 
                    game_number > pred_num + 3):
                    self.prediction_status[pred_num] = '‚ùå'
                    self.status_log.append((pred_num, '‚ùå'))
                    yaml_manager.save_predictions(self.prediction_status)
                    logger.info(f"‚ùå Pr√©diction #{pred_num} marqu√©e √©chec - jeu #{game_number} d√©passe pr√©dit+3")
                    return False, pred_num
            
            logger.info(f"Aucune pr√©diction correspondante trouv√©e pour le jeu #{game_number} dans les offsets 0-3")
            pending = [k for k, v in self.prediction_status.items() if v == '‚åõ']
            logger.info(f"Pr√©dictions actuelles en attente: {pending}")
            return None, None
            
        except Exception as e:
            logger.error(f"Erreur verify_prediction: {e}")
            return None, None
    
    def get_statistics(self):
        """Obtenir les statistiques des pr√©dictions"""
        try:
            total = len(self.status_log)
            if total == 0:
                return {
                    'total': 0,
                    'wins': 0,
                    'losses': 0,
                    'pending': len([s for s in self.prediction_status.values() if s == '‚åõ']),
                    'win_rate': 0.0
                }
            
            wins = sum(1 for _, status in self.status_log if '‚úÖ' in status)
            losses = sum(1 for _, status in self.status_log if '‚ùå' in status)
            pending = len([s for s in self.prediction_status.values() if s == '‚åõ'])
            win_rate = (wins / total * 100) if total > 0 else 0.0
            
            return {
                'total': total,
                'wins': wins,
                'losses': losses,
                'pending': pending,
                'win_rate': win_rate
            }
        except Exception as e:
            logger.error(f"Erreur get_statistics: {e}")
            return {'total': 0, 'wins': 0, 'losses': 0, 'pending': 0, 'win_rate': 0.0}

predictor = SimplePredictor()

# Configuration
CONFIG_FILE = "bot_config.json"

def load_config():
    """Charge la configuration depuis le fichier JSON avec valeurs par d√©faut"""
    global detected_stat_channel, detected_display_channel, prediction_interval
    
    # Configuration par d√©faut
    default_stat_channel = -1002646551216
    default_display_channel = -1002716137113
    
    try:
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                detected_stat_channel = config.get('stat_channel', default_stat_channel)
                detected_display_channel = config.get('display_channel', default_display_channel)
                prediction_interval = config.get('prediction_interval', 1)
        else:
            # Si pas de fichier config, utiliser les valeurs par d√©faut
            detected_stat_channel = default_stat_channel
            detected_display_channel = default_display_channel
            prediction_interval = 1
            # Sauvegarder la config par d√©faut
            save_config()
            
        logger.info(f"‚úÖ Configuration: Stats={detected_stat_channel}, Display={detected_display_channel}, Intervalle={prediction_interval}min")
        return True
    except Exception as e:
        logger.error(f"Erreur chargement config: {e}")
        # En cas d'erreur, utiliser les valeurs par d√©faut
        detected_stat_channel = default_stat_channel
        detected_display_channel = default_display_channel
        prediction_interval = 1
    
    return True

def save_config():
    """Sauvegarde la configuration dans le fichier JSON"""
    try:
        config = {
            'stat_channel': detected_stat_channel,
            'display_channel': detected_display_channel,
            'prediction_interval': prediction_interval
        }
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
        logger.info("‚úÖ Configuration sauvegard√©e")
        return True
    except Exception as e:
        logger.error(f"Erreur sauvegarde config: {e}")
        return False

# Health check pour Render.com
async def health_check(request):
    """Health check endpoint pour Render.com"""
    return web.Response(text=f"‚úÖ Bot Telegram Pr√©diction v2024 - Port {PORT} - Running OK!", status=200)

async def bot_status_endpoint(request):
    """Endpoint de statut d√©taill√©"""
    try:
        status = {
            "bot_online": True,
            "port": PORT,
            "stat_channel": detected_stat_channel,
            "display_channel": detected_display_channel,
            "prediction_interval": prediction_interval,
            "predictions_active": len(predictor.prediction_status),
            "yaml_database": "active",
            "timestamp": datetime.now().isoformat()
        }
        return web.json_response(status)
    except Exception as e:
        return web.json_response({"error": str(e)}, status=500)

# --- COMMANDES TELEGRAM ---

@client.on(events.NewMessage(pattern='/start'))
async def start_command(event):
    """Commande de d√©marrage"""
    
    # V√©rifier l'acc√®s aux canaux configur√©s
    stat_status = "‚úÖ Configur√©"
    display_status = "‚úÖ Configur√©"
    
    try:
        await client.get_entity(detected_stat_channel)
    except:
        stat_status = "‚ö†Ô∏è Acc√®s limit√©"
        
    try:
        await client.get_entity(detected_display_channel)
    except:
        display_status = "‚ö†Ô∏è Acc√®s limit√©"
    
    welcome_msg = f"""üéØ **Bot de Pr√©diction v2024 - ACTIF !**

üîπ **Configuration Automatique** - Pr√™t √† fonctionner
üîπ **Logique As Optimis√©e** - 1 As premier + 0 As deuxi√®me groupe
üîπ **Port {PORT}** - Render.com

**√âtat des Canaux** :
üìä Canal Stats ({detected_stat_channel}): {stat_status}
üì¢ Canal Display ({detected_display_channel}): {display_status}

**Fonctionnement** :
‚úÖ **Surveillance automatique** du canal stats
‚úÖ **Pr√©dictions automatiques** selon logique des As  
‚úÖ **Diffusion automatique** des pr√©dictions
‚úÖ **V√©rification automatique** des r√©sultats

**Commandes Disponibles** :
‚Ä¢ `/status` - √âtat d√©taill√© du syst√®me
‚Ä¢ `/config` - Voir configuration actuelle
‚Ä¢ `/set_stat [ID]` - Changer canal stats
‚Ä¢ `/set_display [ID]` - Changer canal display

üöÄ **Le bot fonctionne automatiquement !**
Aucune commande requise - surveille et pr√©dit en temps r√©el."""
    
    await event.respond(welcome_msg)
    logger.info(f"Message bienvenue envoy√© √† {event.sender_id} avec √©tat canaux")

@client.on(events.NewMessage(pattern='/status'))
async def status_command(event):
    """Affiche le statut complet du syst√®me"""
    if event.sender_id != ADMIN_ID:
        return
    
    try:
        # Statistiques du pr√©dicteur
        pred_stats = predictor.get_statistics()
        pred_status = f"""üéØ **Pr√©dicteur**:
‚Ä¢ Total pr√©dictions: {pred_stats['total']}
‚Ä¢ R√©ussites: {pred_stats['wins']} ‚úÖ
‚Ä¢ √âchecs: {pred_stats['losses']} ‚ùå
‚Ä¢ En attente: {pred_stats['pending']} ‚è≥
‚Ä¢ Taux r√©ussite: {pred_stats['win_rate']:.1f}%"""
        
        status_msg = f"""üìä **√âtat du Bot v2024**

üåê **Configuration**:
‚Ä¢ Canal statistiques: {'‚úÖ' if detected_stat_channel else '‚ùå'} ({detected_stat_channel})
‚Ä¢ Canal affichage: {'‚úÖ' if detected_display_channel else '‚ùå'} ({detected_display_channel})
‚Ä¢ Port serveur: {PORT}
‚Ä¢ Intervalle pr√©diction: {prediction_interval} minute(s)

{pred_status}

üîß **Architecture**:
‚Ä¢ Base donn√©es: YAML (autonome)
‚Ä¢ Logique As: 1 premier + 0 deuxi√®me groupe
‚Ä¢ Version: v2024 Render.com"""
        
        await event.respond(status_msg)
        
    except Exception as e:
        logger.error(f"Erreur status: {e}")
        await event.respond(f"‚ùå Erreur: {e}")

@client.on(events.NewMessage(pattern=r'/intervalle (\d+)'))
async def set_prediction_interval(event):
    """Configure l'intervalle de pr√©diction"""
    if event.sender_id != ADMIN_ID:
        return
        
    try:
        global prediction_interval
        new_interval = int(event.pattern_match.group(1))
        
        if 1 <= new_interval <= 60:
            old_interval = prediction_interval
            prediction_interval = new_interval
            
            # Sauvegarder la configuration
            save_config()
            
            await event.respond(f"""‚úÖ **Intervalle de Pr√©diction Mis √† Jour**

‚è±Ô∏è **Ancien**: {old_interval} minute(s)
‚è±Ô∏è **Nouveau**: {prediction_interval} minute(s)

Configuration sauvegard√©e automatiquement.""")
            
            logger.info(f"‚úÖ Intervalle mis √† jour: {old_interval} ‚Üí {prediction_interval} minutes")
        else:
            await event.respond("‚ùå **Erreur**: L'intervalle doit √™tre entre 1 et 60 minutes")
            
    except ValueError:
        await event.respond("‚ùå **Erreur**: Veuillez entrer un nombre valide")
    except Exception as e:
        logger.error(f"Erreur set_prediction_interval: {e}")
        await event.respond(f"‚ùå Erreur: {e}")

@client.on(events.NewMessage(pattern=r'/set_stat (-?\d+)'))
async def set_stat_channel(event):
    """Configure le canal de statistiques"""
    if event.sender_id != ADMIN_ID:
        return
        
    try:
        global detected_stat_channel
        channel_id = int(event.pattern_match.group(1))
        
        # V√©rifier l'acc√®s au canal
        try:
            channel = await client.get_entity(channel_id)
            channel_title = getattr(channel, 'title', f'Canal {channel_id}')
        except Exception as e:
            await event.respond(f"‚ùå **Erreur**: Impossible d'acc√©der au canal {channel_id}\n{str(e)}")
            return
        
        detected_stat_channel = channel_id
        save_config()
        
        await event.respond(f"""‚úÖ **Canal Statistiques Configur√©**

üîó **Canal**: {channel_title}
üÜî **ID**: {channel_id}

Le bot surveillera maintenant ce canal pour les messages de jeu.""")
        
        logger.info(f"‚úÖ Canal stats configur√©: {channel_id} ({channel_title})")
        
    except ValueError:
        await event.respond("‚ùå **Erreur**: ID de canal invalide")
    except Exception as e:
        logger.error(f"Erreur set_stat_channel: {e}")
        await event.respond(f"‚ùå Erreur: {e}")

@client.on(events.NewMessage(pattern=r'/set_display (-?\d+)'))
async def set_display_channel(event):
    """Configure le canal d'affichage des pr√©dictions"""
    if event.sender_id != ADMIN_ID:
        return
        
    try:
        global detected_display_channel
        channel_id = int(event.pattern_match.group(1))
        
        # V√©rifier l'acc√®s au canal et les permissions
        try:
            channel = await client.get_entity(channel_id)
            channel_title = getattr(channel, 'title', f'Canal {channel_id}')
            
            # Tester l'envoi d'un message de test
            test_message = await client.send_message(channel_id, "üîß Test de configuration - Canal d'affichage configur√© avec succ√®s !")
            
        except Exception as e:
            await event.respond(f"‚ùå **Erreur**: Impossible d'envoyer dans le canal {channel_id}\n{str(e)}")
            return
        
        detected_display_channel = channel_id
        save_config()
        
        await event.respond(f"""‚úÖ **Canal Affichage Configur√©**

üîó **Canal**: {channel_title}
üÜî **ID**: {channel_id}

Les pr√©dictions seront maintenant diffus√©es sur ce canal.""")
        
        logger.info(f"‚úÖ Canal affichage configur√©: {channel_id} ({channel_title})")
        
    except ValueError:
        await event.respond("‚ùå **Erreur**: ID de canal invalide")
    except Exception as e:
        logger.error(f"Erreur set_display_channel: {e}")
        await event.respond(f"‚ùå Erreur: {e}")

@client.on(events.NewMessage(pattern='/config'))
async def show_config(event):
    """Affiche la configuration actuelle"""
    if event.sender_id != ADMIN_ID:
        return
    
    try:
        # Obtenir les noms des canaux
        stat_name = "Non configur√©"
        display_name = "Non configur√©"
        
        if detected_stat_channel:
            try:
                stat_channel = await client.get_entity(detected_stat_channel)
                stat_name = getattr(stat_channel, 'title', f'Canal {detected_stat_channel}')
            except:
                stat_name = f"Canal {detected_stat_channel} (inaccessible)"
        
        if detected_display_channel:
            try:
                display_channel = await client.get_entity(detected_display_channel)
                display_name = getattr(display_channel, 'title', f'Canal {detected_display_channel}')
            except:
                display_name = f"Canal {detected_display_channel} (inaccessible)"
        
        config_msg = f"""üîß **Configuration Actuelle**

üìä **Canal Statistiques**:
‚Ä¢ Nom: {stat_name}
‚Ä¢ ID: {detected_stat_channel or 'Non configur√©'}

üì¢ **Canal Affichage**:
‚Ä¢ Nom: {display_name}  
‚Ä¢ ID: {detected_display_channel or 'Non configur√©'}

‚öôÔ∏è **Param√®tres**:
‚Ä¢ Intervalle pr√©diction: {prediction_interval} minute(s)
‚Ä¢ Port: {PORT}

**Commandes de Configuration**:
‚Ä¢ `/set_stat [ID]` - Configurer canal stats
‚Ä¢ `/set_display [ID]` - Configurer canal affichage
‚Ä¢ `/intervalle [1-60]` - Configurer intervalle"""
        
        await event.respond(config_msg)
        
    except Exception as e:
        logger.error(f"Erreur show_config: {e}")
        await event.respond(f"‚ùå Erreur: {e}")

# Messages handler principal avec logique As
@client.on(events.NewMessage())
@client.on(events.MessageEdited())
async def handle_messages(event):
    """Gestionnaire principal des messages"""
    try:
        message_text = event.message.message if event.message else ""
        channel_id = event.chat_id
        
        # V√©rifier si c'est le bon canal
        if detected_stat_channel and channel_id == detected_stat_channel:
            logger.info(f"‚úÖ Message du canal stats: {message_text[:100]}")
            
            # Logique de pr√©diction avec analyse des As
            should_predict, game_number, suit = predictor.should_predict(message_text)
            if should_predict and game_number and suit:
                prediction_text = f"üîµ{game_number} üîµ3D: statut :‚è≥"
                logger.info(f"üéØ Pr√©diction g√©n√©r√©e: {prediction_text}")
                
                # Enregistrer la pr√©diction
                predictor.prediction_status[game_number] = '‚åõ'
                predictor.last_predictions.append((game_number, suit))
                yaml_manager.save_predictions(predictor.prediction_status)
                logger.info(f"‚úÖ Pr√©diction cr√©√©e: Jeu #{game_number} -> {suit}")
                
                # Diffuser la pr√©diction automatiquement
                if detected_display_channel:
                    try:
                        # Essayer d'obtenir l'entit√© du canal d'abord
                        try:
                            display_entity = await client.get_entity(detected_display_channel)
                        except:
                            # Si impossible d'obtenir l'entit√©, utiliser directement l'ID
                            display_entity = detected_display_channel
                            
                        await client.send_message(display_entity, prediction_text)
                        logger.info(f"üì§ Pr√©diction diffus√©e automatiquement sur canal {detected_display_channel}")
                    except Exception as e:
                        logger.error(f"‚ùå Erreur diffusion sur {detected_display_channel}: {e}")
                        # Essayer avec l'ID direct en cas d'erreur d'entit√©
                        try:
                            await client.send_message(detected_display_channel, prediction_text)
                            logger.info(f"üì§ Pr√©diction diffus√©e (ID direct) sur canal {detected_display_channel}")
                        except Exception as e2:
                            logger.error(f"‚ùå √âchec total diffusion: {e2}")
                else:
                    logger.warning("‚ö†Ô∏è Canal display non configur√©, pr√©diction non diffus√©e")
            
            # V√©rification des r√©sultats
            verified, number = predictor.verify_prediction(message_text)
            if verified is not None and number is not None:
                status = predictor.prediction_status.get(number, '‚ùå')
                logger.info(f"üîç V√©rification jeu #{number}: {status}")
                
                # Mettre √† jour le message de pr√©diction si possible
                if detected_display_channel and verified:
                    try:
                        # Chercher le message de pr√©diction correspondant pour le mettre √† jour
                        logger.info(f"Message de pr√©diction #{number} mis √† jour avec statut: {status}")
                    except Exception as e:
                        logger.error(f"Erreur mise √† jour message: {e}")
                
        else:
            logger.debug(f"Message ignor√© - Canal {channel_id} ‚â† Stats {detected_stat_channel}")
            
    except Exception as e:
        logger.error(f"Erreur handle_messages: {e}")

# D√©marrage serveur web
async def start_web_server():
    """D√©marre le serveur web pour Render.com"""
    app = web.Application()
    app.router.add_get('/', health_check)
    app.router.add_get('/health', health_check)
    app.router.add_get('/status', bot_status_endpoint)
    
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', PORT)
    await site.start()
    logger.info(f"‚úÖ Serveur web d√©marr√© sur 0.0.0.0:{PORT}")

async def main():
    """Fonction principale"""
    try:
        logger.info("üöÄ D√©marrage Bot Pr√©diction v2024")
        
        # V√©rifier les variables d'environnement
        if not API_ID or not API_HASH or not BOT_TOKEN or not ADMIN_ID:
            logger.error("‚ùå Variables d'environnement manquantes!")
            return
            
        logger.info(f"‚úÖ Configuration: API_ID={API_ID}, ADMIN_ID={ADMIN_ID}, PORT={PORT}")
        
        # Charger configuration avec valeurs par d√©faut
        load_config()
        logger.info(f"üéØ Canaux pr√©-configur√©s: Stats={detected_stat_channel}, Display={detected_display_channel}")
        
        # D√©marrer serveur web
        await start_web_server()
        
        # D√©marrer bot Telegram
        logger.info("üîó Connexion au bot Telegram...")
        await client.start(bot_token=BOT_TOKEN)
        
        me = await client.get_me()
        logger.info(f"‚úÖ Bot connect√©: @{me.username}")
        logger.info("üîÑ Bot en ligne et en attente de messages...")
        logger.info(f"üåê Acc√®s web: http://0.0.0.0:{PORT}")
        
        # Boucle principale
        await client.run_until_disconnected()
        
    except Exception as e:
        logger.error(f"‚ùå Erreur critique: {e}")
        raise

if __name__ == "__main__":
    asyncio.run(main())